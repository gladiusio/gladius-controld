package handlers

import (
	"errors"
	"io/ioutil"
	"net/http"

	"github.com/buger/jsonparser"

	"github.com/gladiusio/gladius-controld/pkg/blockchain"
	"github.com/gladiusio/gladius-controld/pkg/p2p/message"
	"github.com/gladiusio/gladius-controld/pkg/p2p/peer"
	"github.com/gladiusio/gladius-controld/pkg/p2p/signature"
)

func parseSignedMessageFromBytes(smBytes []byte) (*signature.SignedMessage, error) {
	messageBytes, _, _, err := jsonparser.Get(smBytes, "message")
	if err != nil {
		return nil, errors.New("Can't find `message` in body")
	}

	hash, err := jsonparser.GetString(smBytes, "hash")
	if err != nil {
		return nil, errors.New("Can't find `hash` in body")
	}

	signatureString, err := jsonparser.GetString(smBytes, "signature")
	if err != nil {
		return nil, errors.New("Could not find `signature` in body")

	}

	address, err := jsonparser.GetString(smBytes, "address")
	if err != nil {
		return nil, errors.New("Could not find `address` in body")
	}

	parsed, err := signature.ParseSignedMessage(string(messageBytes), hash, signatureString, address)
	if err != nil {
		return nil, errors.New("Couldn't parse body")

	}

	return parsed, nil
}

// Helper to create signed message from body
func getSignedMessageFromBody(w http.ResponseWriter, r *http.Request) *signature.SignedMessage {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
		return nil
	}

	sm, err := parseSignedMessageFromBytes(body)

	if err != nil {
		ErrorHandler(w, r, "Error parsing signed message", err, http.StatusBadRequest)
	}

	return sm
}

// Helper to get fields from the json body and verify the signature
func verifyBody(w http.ResponseWriter, r *http.Request) (bool, *signature.SignedMessage) {
	parsed := getSignedMessageFromBody(w, r)
	if parsed == nil {
		return false, nil
	}
	verified := parsed.IsInPoolAndVerified()

	return verified, parsed
}

// Gets a content list from an incoming comparison request
func getContentListFromBody(w http.ResponseWriter, r *http.Request) []interface{} {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
		return nil
	}
	s := make([]interface{}, 0)
	// Get all content file names passed in
	jsonparser.ArrayEach(body, func(value []byte, dataType jsonparser.ValueType, offset int, err error) {
		s = append(s, string(value))
	}, "content")

	return s
}

// VerifySignedMessageHandler verifies the incoming message with takes the form
// of:
// {"message": "b64string", "hash": "b64string", "signature": "b64string", "address": ""}
func VerifySignedMessageHandler(w http.ResponseWriter, r *http.Request) {
	v, _ := verifyBody(w, r)
	if v {
		ResponseHandler(w, r, "Message is verified", true, nil, true, nil)
	} else {
		ResponseHandler(w, r, "Message is not verified", true, nil, false, nil)
	}
}

/*******************************************************************************
All methods below use the account generated by the gladius account manager
*******************************************************************************/

// CreateSignedMessageHandler takes the incoming message and returns a signed
// version that includes the timestamp.

func CreateSignedMessageHandler(ga *blockchain.GladiusAccountManager) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
			return
		}
		messageBytes, _, _, err := jsonparser.Get(body, "message")
		if err != nil {
			ErrorHandler(w, r, "Could not find `message` in body", err, http.StatusBadRequest)
			return
		}

		signed, err := signature.CreateSignedMessage(message.New(messageBytes), ga)
		if err != nil {
			ErrorHandler(w, r, "Could not create sign message. Wallet likely locked.", err, http.StatusBadRequest)
			return
		}

		ResponseHandler(w, r, "Created signed message", true, nil, signed, nil)
	}
}

// PushStateMessageHandler updates state with signed update and pushes state to
// a set of random peers. They then propigate it to their peers until the
// network has a consistent state
func PushStateMessageHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		v, sm := verifyBody(w, r)
		if v {
			err := p.UpdateAndPushState(sm)
			if err != nil {
				ErrorHandler(w, r, "Error updating state", err, http.StatusBadRequest)
			} else {
				ResponseHandler(w, r, "Message was pushed. This does not necessarily mean that the message was recieved by peers.", true, nil, true, nil)
			}
		} else {
			if sm != nil {
				ErrorHandler(w, r, "Cannot verifiy signature", errors.New("cannot verifiy signature"), http.StatusBadRequest)
			}
		}
	}
}

func getIntroductionDataFromBody(w http.ResponseWriter, r *http.Request) (ip string, signedMessage []byte) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
		return "", []byte("")
	}

	ip, err = jsonparser.GetString(body, "ip")
	if err != nil {
		ErrorHandler(w, r, "Could not find `ip` in body", err, http.StatusBadRequest)
		return "", []byte("")
	}

	return ip, signedMessage
}

// JoinHandler takes in an IP and tries to join it's cluster
func JoinHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		ip, _ := getIntroductionDataFromBody(w, r)
		if ip != "" {
			err := p.Join([]string{ip})
			if err != nil {
				ErrorHandler(w, r, "Couldn't join network", err, http.StatusBadRequest)
				return
			}
			ResponseHandler(w, r, "Requested to join pool", true, nil, nil, nil)
			return
		}
		ErrorHandler(w, r, "IP can't be empty", nil, http.StatusBadRequest)

	}
}

func LeaveHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		err := p.StopAndLeave()
		if err != nil {
			ErrorHandler(w, r, "Couldn't leave network", err, http.StatusBadRequest)
			return
		}
		ResponseHandler(w, r, "Pulled state and sent introduction", true, nil, nil, nil)
	}
}

// GetFullStateHandler gets the current state the node has access to.
func GetFullStateHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		state := p.GetState()
		ResponseHandler(w, r, "Got full state", true, nil, state, nil)
	}
}

// GetSignatureListHandler gets the list of signatures used to create the current
// state
func GetSignatureListHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		ResponseHandler(w, r, "Fetched signature list. This can be used to rebuild a verified state.", true, nil, p.GetState().GetSignatureList(), nil)
	}
}

// GetContentHandler will compare the content list provided with the
// current state and return a list of links to download content from a peer that
// has the same set as the network state. It also includes a hash of that file
// so the node can verify it before serving.
func GetContentHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		c := getContentListFromBody(w, r)
		ResponseHandler(w, r, "Got needed content", true, nil, p.CompareContent(c), nil)
	}
}

func GetContentLinksHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		c := getContentListFromBody(w, r)
		ResponseHandler(w, r, "Got needed content links", true, nil, p.GetContentLinks(c), nil)
	}
}
